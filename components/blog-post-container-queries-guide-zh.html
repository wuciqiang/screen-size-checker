<!-- Blog Post: CSS 容器查询完全指南：告别媒体查询的痛点 -->
<article class="blog-post">
    <header class="blog-post-header">
        <h1 class="blog-post-title">CSS 容器查询完全指南：告别媒体查询的痛点</h1>
        <div class="blog-post-meta">
            <span class="blog-post-date">2025年1月9日</span>
            <span class="blog-post-author">Screen Size Checker 团队</span>
            <span class="blog-post-reading-time">5 分钟阅读</span>
        </div>
        <!-- Featured image temporarily disabled until images are created -->
    </header>
    
    <div class="blog-post-content">
        <h2 id="css-容器查询完全指南：告别媒体查询的痛点">CSS 容器查询完全指南：告别媒体查询的痛点</h2>
<p>多年来，响应式网页设计一直依赖媒体查询来适配不同的屏幕尺寸。但当你需要组件根据其容器的大小而非视口大小进行响应时，该怎么办？CSS 容器查询应运而生——这个革命性的特性正在重塑我们在 2025 年对响应式设计的思考方式。</p>
<h2 id="为什么我们迫切需要容器查询">为什么我们迫切需要容器查询</h2>
<p>想象这样一个场景：你构建了一个在桌面端看起来完美的卡片组件。左侧有图片，右侧有内容，一切都很平衡。现在你需要在一个狭窄的侧边栏中使用这个相同的组件。使用媒体查询，你束手无策——组件只知道视口宽度，而不知道它实际可用的空间。</p>
<pre><code class="language-css"><span class="hljs-comment">/* 使用媒体查询的旧方法 - 存在问题 */</span>
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) {
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">display</span>: flex;
  }
}
<span class="hljs-comment">/* 但如果这个卡片在 1920px 屏幕上的 300px 侧边栏中呢？ */</span>
</code></pre>
<p>这个根本性的限制困扰了开发者多年，导致组件重复、复杂的命名约定和维护噩梦。容器查询通过允许组件响应其容器的大小来优雅地解决这个问题。</p>
<h2 id="理解容器查询：基础知识">理解容器查询：基础知识</h2>
<h3 id="容器查询到底是什么？">容器查询到底是什么？</h3>
<p>容器查询允许元素根据其包含元素的大小而不是视口来调整样式。这意味着组件可以真正做到自包含和响应式，无论它被放置在布局的什么位置。</p>
<p><strong>与媒体查询的关键区别：</strong></p>
<ul>
<li><strong>媒体查询</strong>：响应视口/设备特性</li>
<li><strong>容器查询</strong>：响应父容器尺寸</li>
<li><strong>作用域</strong>：媒体查询是全局的，容器查询限定于特定容器</li>
</ul>
<h3 id="2025-年的浏览器支持">2025 年的浏览器支持</h3>
<p>好消息！截至 2025 年，容器查询有着出色的浏览器支持：</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>版本</th>
<th>支持情况</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>105+</td>
<td>✅ 完全支持</td>
</tr>
<tr>
<td>Firefox</td>
<td>110+</td>
<td>✅ 完全支持</td>
</tr>
<tr>
<td>Safari</td>
<td>16+</td>
<td>✅ 完全支持</td>
</tr>
<tr>
<td>Edge</td>
<td>105+</td>
<td>✅ 完全支持</td>
</tr>
</tbody></table>
<p>超过 90% 的用户现在使用支持的浏览器，容器查询已经可以用于大多数生产项目。</p>
<h3 id="基本语法和设置">基本语法和设置</h3>
<pre><code class="language-css"><span class="hljs-comment">/* 步骤 1：定义容器 */</span>
<span class="hljs-selector-class">.card-wrapper</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
  <span class="hljs-comment">/* 或者 */</span>
  <span class="hljs-attribute">container</span>: card / inline-size; <span class="hljs-comment">/* 带名称 */</span>
}

<span class="hljs-comment">/* 步骤 2：查询容器 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;
  }
}

<span class="hljs-comment">/* 或查询命名容器 */</span>
<span class="hljs-keyword">@container</span> card (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card-title</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;
  }
}
</code></pre>
<h2 id="实际应用和示例">实际应用和示例</h2>
<h3 id="示例-1：自适应卡片组件">示例 1：自适应卡片组件</h3>
<p>让我们构建一个能够智能适应可用空间的卡片组件：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.card-container</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
}

<span class="hljs-selector-class">.card</span> {
  <span class="hljs-attribute">background</span>: white;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);
}

<span class="hljs-comment">/* 窄容器：垂直堆叠 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &lt; <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;
  }
  
  <span class="hljs-selector-class">.card-image</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">object-fit</span>: cover;
  }
  
  <span class="hljs-selector-class">.card-content</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-selector-class">.card-title</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.25rem</span>;
  }
}

<span class="hljs-comment">/* 中等容器：带小图片的并排布局 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-number">400px</span> &lt;= <span class="hljs-attribute">width</span> &lt; <span class="hljs-number">600px</span>) {
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;
  }
  
  <span class="hljs-selector-class">.card-image</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;
    <span class="hljs-attribute">object-fit</span>: cover;
    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-selector-class">.card-title</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5rem</span>;
  }
}

<span class="hljs-comment">/* 大容器：宽敞的布局 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &gt;= <span class="hljs-number">600px</span>) {
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">2rem</span>;
  }
  
  <span class="hljs-selector-class">.card-image</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">object-fit</span>: cover;
    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-selector-class">.card-title</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.75rem</span>;
    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0.5rem</span>;
  }
  
  <span class="hljs-selector-class">.card-description</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.1rem</span>;
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;
  }
}
</code></pre>
<h3 id="示例-2：响应式导航菜单">示例 2：响应式导航菜单</h3>
<p>容器查询在创建适应可用空间的导航组件方面表现出色：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.nav-container</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}

<span class="hljs-selector-class">.nav-menu</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
}

<span class="hljs-comment">/* 窄容器中的移动端样式菜单 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &lt; <span class="hljs-number">500px</span>) {
  <span class="hljs-selector-class">.nav-menu</span> {
    <span class="hljs-attribute">flex-direction</span>: column;
  }
  
  <span class="hljs-selector-class">.nav-item</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0.75rem</span>;
    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;
  }
  
  <span class="hljs-selector-class">.nav-dropdown</span> {
    <span class="hljs-attribute">position</span>: static;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  }
}

<span class="hljs-comment">/* 宽容器中的水平菜单和下拉菜单 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &gt;= <span class="hljs-number">500px</span>) {
  <span class="hljs-selector-class">.nav-menu</span> {
    <span class="hljs-attribute">flex-direction</span>: row;
    <span class="hljs-attribute">justify-content</span>: space-between;
  }
  
  <span class="hljs-selector-class">.nav-item</span> {
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0.5rem</span> <span class="hljs-number">1rem</span>;
  }
  
  <span class="hljs-selector-class">.nav-dropdown</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">min-width</span>: <span class="hljs-number">200px</span>;
  }
}
</code></pre>
<h3 id="示例-3：动态网格布局">示例 3：动态网格布局</h3>
<p>创建基于容器宽度而非视口调整的网格：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.grid-container</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}

<span class="hljs-selector-class">.product-grid</span> {
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
}

<span class="hljs-comment">/* 窄容器的单列 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &lt; <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.product-grid</span> {
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr;
  }
}

<span class="hljs-comment">/* 中等容器的两列 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-number">400px</span> &lt;= <span class="hljs-attribute">width</span> &lt; <span class="hljs-number">800px</span>) {
  <span class="hljs-selector-class">.product-grid</span> {
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>fr);
  }
}

<span class="hljs-comment">/* 宽容器的三列 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &gt;= <span class="hljs-number">800px</span>) {
  <span class="hljs-selector-class">.product-grid</span> {
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);
  }
}

<span class="hljs-comment">/* 超宽容器的四列 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">width</span> &gt;= <span class="hljs-number">1200px</span>) {
  <span class="hljs-selector-class">.product-grid</span> {
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>fr);
  }
}
</code></pre>
<h2 id="高级技术和容器单位">高级技术和容器单位</h2>
<h3 id="容器查询单位">容器查询单位</h3>
<p>容器查询引入了相对于容器尺寸的新 CSS 单位：</p>
<ul>
<li><strong>cqw</strong>：容器宽度的 1%</li>
<li><strong>cqh</strong>：容器高度的 1%</li>
<li><strong>cqi</strong>：容器内联大小的 1%</li>
<li><strong>cqb</strong>：容器块大小的 1%</li>
<li><strong>cqmin</strong>：cqi 或 cqb 的较小值</li>
<li><strong>cqmax</strong>：cqi 或 cqb 的较大值</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.responsive-text</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}

<span class="hljs-selector-class">.responsive-text</span> <span class="hljs-selector-tag">h2</span> {
  <span class="hljs-comment">/* 字体大小随容器宽度缩放 */</span>
  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">1.5rem</span>, <span class="hljs-number">5</span>cqi, <span class="hljs-number">3rem</span>);
  
  <span class="hljs-comment">/* 相对于容器的内边距 */</span>
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2</span>cqi <span class="hljs-number">4</span>cqi;
}

<span class="hljs-selector-class">.responsive-text</span> <span class="hljs-selector-tag">p</span> {
  <span class="hljs-comment">/* 适应容器的行高 */</span>
  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0.875rem</span>, <span class="hljs-number">2</span>cqi, <span class="hljs-number">1.125rem</span>);
  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;
  
  <span class="hljs-comment">/* 随容器缩放的外边距 */</span>
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">3</span>cqb;
}
</code></pre>
<h3 id="结合容器查询和媒体查询">结合容器查询和媒体查询</h3>
<p>为了获得最佳的响应式体验，结合使用两种方法：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.article-layout</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}

<span class="hljs-comment">/* 基础移动优先样式 */</span>
<span class="hljs-selector-class">.article-content</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
}

<span class="hljs-comment">/* 响应视口的主要布局变化 */</span>
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1024px</span>) {
  <span class="hljs-selector-class">.article-layout</span> {
    <span class="hljs-attribute">display</span>: grid;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">300px</span>;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">2rem</span>;
  }
}

<span class="hljs-comment">/* 基于实际容器大小的微调 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>) {
  <span class="hljs-selector-class">.article-content</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2rem</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.125rem</span>;
  }
  
  <span class="hljs-selector-class">.article-content</span> <span class="hljs-selector-tag">h2</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2rem</span> <span class="hljs-number">0</span> <span class="hljs-number">1rem</span>;
  }
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) {
  <span class="hljs-selector-class">.article-content</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">3rem</span>;
    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">65ch</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
  }
}
</code></pre>
<h2 id="使用屏幕尺寸工具测试容器查询">使用屏幕尺寸工具测试容器查询</h2>
<p>要有效测试你的容器查询，你需要合适的工具。我们的<a href="https://screensizechecker.com/zh/devices/responsive-tester">响应式设计测试器</a>非常适合这个任务：</p>
<ol>
<li><strong>测试不同的容器尺寸</strong>：使用拖动调整大小功能查看组件如何在各种容器宽度下响应</li>
<li><strong>设备预设</strong>：检查容器在不同设备视口中的表现</li>
<li><strong>实时更新</strong>：观察容器查询在调整大小时的触发情况</li>
</ol>
<p>要根据内容计算最佳断点，我们的<a href="https://screensizechecker.com/zh/devices/aspect-ratio-calculator">纵横比计算器</a>可以帮助确定布局的最佳容器尺寸。</p>
<h2 id="性能考虑">性能考虑</h2>
<h3 id="性能最佳实践">性能最佳实践</h3>
<ol>
<li><strong>避免深层嵌套</strong></li>
</ol>
<pre><code class="language-css"><span class="hljs-comment">/* 避免 */</span>
<span class="hljs-selector-class">.container1</span> { <span class="hljs-attribute">container-type</span>: inline-size; }
  <span class="hljs-selector-class">.container2</span> { <span class="hljs-attribute">container-type</span>: inline-size; }
    <span class="hljs-selector-class">.container3</span> { <span class="hljs-attribute">container-type</span>: inline-size; }

<span class="hljs-comment">/* 更好 */</span>
<span class="hljs-selector-class">.component-container</span> { <span class="hljs-attribute">container-type</span>: inline-size; }
</code></pre>
<ol start="2">
<li><strong>明智地使用容器</strong></li>
</ol>
<pre><code class="language-css"><span class="hljs-comment">/* 只在需要的地方设置 container-type */</span>
<span class="hljs-selector-class">.card-grid</span> {
  <span class="hljs-comment">/* 这里不需要 container-type */</span>
}

<span class="hljs-selector-class">.card-wrapper</span> {
  <span class="hljs-attribute">container-type</span>: inline-size; <span class="hljs-comment">/* 只在直接父元素上 */</span>
}
</code></pre>
<ol start="3">
<li><strong>优化查询条件</strong></li>
</ol>
<pre><code class="language-css"><span class="hljs-comment">/* 高效使用逻辑组合 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-number">400px</span> &lt;= <span class="hljs-attribute">width</span> &lt; <span class="hljs-number">800px</span>) {
  <span class="hljs-comment">/* 中等容器的样式 */</span>
}

<span class="hljs-comment">/* 避免冗余查询 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">799px</span>) {
  <span class="hljs-comment">/* 与上面相同但更冗长 */</span>
}
</code></pre>
<h3 id="性能指标">性能指标</h3>
<p>正确使用时，容器查询的性能影响很小：</p>
<ul>
<li><strong>绘制时间</strong>：大量使用时增加约 2-5%</li>
<li><strong>布局重新计算</strong>：与媒体查询相似</li>
<li><strong>内存使用</strong>：增加可忽略不计</li>
</ul>
<h2 id="迁移策略：从媒体查询到容器查询">迁移策略：从媒体查询到容器查询</h2>
<h3 id="步骤-1：审核当前样式">步骤 1：审核当前样式</h3>
<p>识别能从容器查询中受益的组件：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 出现在多个上下文中的组件</span>
<span class="hljs-keyword">const</span> candidateComponents = [
  <span class="hljs-string">&#x27;卡片&#x27;</span>,
  <span class="hljs-string">&#x27;导航菜单&#x27;</span>,
  <span class="hljs-string">&#x27;侧边栏&#x27;</span>,
  <span class="hljs-string">&#x27;数据表格&#x27;</span>,
  <span class="hljs-string">&#x27;表单布局&#x27;</span>,
  <span class="hljs-string">&#x27;图片画廊&#x27;</span>
];
</code></pre>
<h3 id="步骤-2：渐进增强方法">步骤 2：渐进增强方法</h3>
<pre><code class="language-css"><span class="hljs-comment">/* 适用于所有地方的基础样式 */</span>
<span class="hljs-selector-class">.card</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">background</span>: white;
}

<span class="hljs-comment">/* 媒体查询的回退方案 */</span>
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) {
  <span class="hljs-keyword">@supports</span> <span class="hljs-keyword">not</span> (<span class="hljs-attribute">container-type</span>: inline-size) {
    <span class="hljs-selector-class">.card</span> {
      <span class="hljs-attribute">display</span>: flex;
    }
  }
}

<span class="hljs-comment">/* 现代容器查询 */</span>
<span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">container-type</span>: inline-size) {
  <span class="hljs-selector-class">.card-wrapper</span> {
    <span class="hljs-attribute">container-type</span>: inline-size;
  }
  
  <span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
    <span class="hljs-selector-class">.card</span> {
      <span class="hljs-attribute">display</span>: flex;
    }
  }
}
</code></pre>
<h3 id="步骤-3：测试和验证">步骤 3：测试和验证</h3>
<p>使用特性检测确保兼容性：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// JavaScript 特性检测</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">supportsContainerQueries</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">containerType</span> = <span class="hljs-string">&#x27;inline-size&#x27;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">containerType</span> === <span class="hljs-string">&#x27;inline-size&#x27;</span>;
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}

<span class="hljs-keyword">if</span> (<span class="hljs-title function_">supportsContainerQueries</span>()) {
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;container-queries-supported&#x27;</span>);
}
</code></pre>
<h2 id="常见陷阱及如何避免">常见陷阱及如何避免</h2>
<h3 id="陷阱-1：忘记设置容器类型">陷阱 1：忘记设置容器类型</h3>
<pre><code class="language-css"><span class="hljs-comment">/* 不会工作 - 没有定义 container-type */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> { <span class="hljs-attribute">display</span>: flex; }
}

<span class="hljs-comment">/* 修复后 */</span>
<span class="hljs-selector-class">.card-wrapper</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> { <span class="hljs-attribute">display</span>: flex; }
}
</code></pre>
<h3 id="陷阱-2：在错误的元素上设置容器类型">陷阱 2：在错误的元素上设置容器类型</h3>
<pre><code class="language-css"><span class="hljs-comment">/* 错误 - 在被样式化的元素上设置 container-type */</span>
<span class="hljs-selector-class">.card</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> { <span class="hljs-comment">/* 这不会工作 */</span> }
}

<span class="hljs-comment">/* 正确 - 在父元素上设置 container-type */</span>
<span class="hljs-selector-class">.card-wrapper</span> {
  <span class="hljs-attribute">container-type</span>: inline-size;
}
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> { <span class="hljs-comment">/* 这会工作 */</span> }
}
</code></pre>
<h3 id="陷阱-3：容器名称冲突">陷阱 3：容器名称冲突</h3>
<pre><code class="language-css"><span class="hljs-comment">/* 命名时要小心 */</span>
<span class="hljs-selector-class">.outer</span> {
  <span class="hljs-attribute">container</span>: layout / inline-size;
}
<span class="hljs-selector-class">.inner</span> {
  <span class="hljs-attribute">container</span>: layout / inline-size; <span class="hljs-comment">/* 相同名称 - 容易混淆 */</span>
}

<span class="hljs-comment">/* 更好 - 使用唯一名称 */</span>
<span class="hljs-selector-class">.outer</span> {
  <span class="hljs-attribute">container</span>: outer-layout / inline-size;
}
<span class="hljs-selector-class">.inner</span> {
  <span class="hljs-attribute">container</span>: inner-layout / inline-size;
}
</code></pre>
<h2 id="总结：容器查询革命">总结：容器查询革命</h2>
<p>容器查询代表了我们对响应式设计思考方式的根本转变。它们使真正模块化、上下文感知的组件能够智能地适应其环境。虽然媒体查询在视口级别的决策中仍有其地位，但容器查询处理了我们一直想要的组件级响应式。</p>
<h3 id="关键要点：">关键要点：</h3>
<ul>
<li><strong>容器查询</strong>使组件真正可重用和上下文感知</li>
<li><strong>浏览器支持</strong>现在足以用于生产（90%+ 覆盖率）</li>
<li><strong>性能影响</strong>在正确使用时很小</li>
<li><strong>迁移</strong>可以通过适当的回退方案逐步进行</li>
<li><strong>未来功能</strong>将使它们更加强大</li>
</ul>
<h3 id="下一步：">下一步：</h3>
<ol>
<li>开始在新组件中尝试容器查询</li>
<li>识别能从迁移中受益的现有组件</li>
<li>使用我们的<a href="https://screensizechecker.com/zh">屏幕尺寸检查器工具</a>测试你的实现</li>
<li>关注样式查询和容器单位的新发展</li>
</ol>
<p>真正响应式组件的时代已经到来。容器查询不仅仅是一个新功能——它们是思考网页设计的新方式。今天就开始使用它们，你未来的自己（和你的团队）会感谢你的。</p>
<hr>
<p><em>想在不同屏幕尺寸上测试你的容器查询吗？试试我们的<a href="https://screensizechecker.com/zh/devices/responsive-tester">免费响应式设计测试器</a>，实时查看你的组件如何适应。想了解更多关于现代 CSS 和响应式设计的文章，请查看我们的<a href="https://screensizechecker.com/zh/blog/">博客</a>。</em></p>

    </div>
    
    <footer class="blog-post-footer">
        <div class="blog-post-tags">
            <a href="tag/css" class="tag-link">#css</a> <a href="tag/响应式设计" class="tag-link">#响应式设计</a> <a href="tag/容器查询" class="tag-link">#容器查询</a> <a href="tag/网页开发" class="tag-link">#网页开发</a> <a href="tag/前端" class="tag-link">#前端</a>
        </div>
        <div class="blog-post-share">
            <span>分享: </span>
            <button class="share-btn share-twitter" data-url="/zh/blog/container-queries-guide" data-title="CSS 容器查询完全指南：告别媒体查询的痛点">Twitter</button>
            <button class="share-btn share-facebook" data-url="/zh/blog/container-queries-guide" data-title="CSS 容器查询完全指南：告别媒体查询的痛点">Facebook</button>
            <button class="share-btn share-linkedin" data-url="/zh/blog/container-queries-guide" data-title="CSS 容器查询完全指南：告别媒体查询的痛点">LinkedIn</button>
            <button class="share-btn share-copy" data-url="/zh/blog/container-queries-guide">复制链接</button>
        </div>
    </footer>
    
    <div class="blog-post-related">
        <h3>相关文章</h3>
        <div class="blog-post-related-container">
            <!-- 相关文章将通过JS动态加载 -->
            <div class="related-posts-placeholder" data-post-id="container-queries-guide" data-post-lang="zh"></div>
        </div>
    </div>
</article>